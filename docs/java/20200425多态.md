---
title: 多态
date: 2020-04-25 20:00:24
tags: java
---
# **多态**

T1 a= new T1();
T2 b= new T1();
区别：
问题1：不是实例化一个a，是实例化一个T1

**T1 的一个 对象的引用 a  指向了堆空间里的一个新T1对象**
<!--more-->

new是java里面的关键字.一般用于创建一个新的对象.
T1 a= new T1();表示创建一个新的T1对象.
T2 b= new T1();这种多用在接口类与实现类之间或子类与父类间
在接口中使用时：T2应该是一个接口类，T1为T2的实现类。
在子类与父类关系时：T2为父类，T1为T2的子类。

这些用法都是Java中多态性的一个表现 
---------------------------------------------------------
JAVA中都是用引用来操作对象，a是引用，new T1()是对象，T1 a = new T1()这段代码，则是将他们连接起来，这样就可以通过a来操作new T1()这个对象；

new这个关键字可以理解为“给我一个新对象”的意思；
那么T1 a = new T1(),可理解为:a说“给我一个新的T1对象”；
**T2 b= new T1();可理解为:b说“给我一个新的T1对象”,可b是属于T2类型的引用，不兼容，所以不能连接T1，因此编译时会报错。**

所以两者区别是，他们同为T1类型的引用，但却连接不同的对象，因为给他们的都是一个新的对象，并不一样。 

T2与T1之间有继承关系吗？？ 如果有，则说明T2为T1的父类，就好像花和玫瑰的关系一样，玫瑰属于玫瑰，玫瑰也属于花，所以T2 b= new T1()也可以建立连接，如果调用的方法在T1里有，则是T1里。 



第一个问题：
这句话 T1 a 是告诉虚拟机，开辟一个可以存放T1类型的空间a
new T1()就是获得一个T1的对象
连起来就是开辟一个可以存放T1实例的空间a，并且指向一个T1的实例。

一般说就是，新建 一个T1的对象a

第二个问题：
T2 b开辟了一个可以存放T2类型的空间
由于T1是T2的子类，所以T1可以放在T2的空间里

这时候调用T1与T2中共有的方法时，由于方法覆盖，所以执行的是T1中的方法
但是由于b的类型是T2，所以b这个对象不可以使用T1类的专有方法(也就是T1有的方法，但是T2没有这个方法)

如果b希望执行T1中的专有方法
将b转换成T1类型，就可以了
也就是做一个这个操作：(T1)b

-------------------------------------------------------------

最后可以再查看这博客，最后巩固一下

https://www.cnblogs.com/chenssy/p/3372798.html

```java
public class Wine {
    public void fun1(){
        System.out.println("Wine 的Fun.....");
        fun2();
    }
    
    public void fun2(){
        System.out.println("Wine 的Fun2...");
    }
}

public class JNC extends Wine{
    /**
     * @desc 子类重载父类方法
     *        父类中不存在该方法，向上转型后，父类是不能引用该方法的
     * @param a
     * @return void
     */
    public void fun1(String a){
        System.out.println("JNC 的 Fun1...");
        fun2();
    }
    
    /**
     * 子类重写父类方法
     * 指向子类的父类引用调用fun2时，必定是调用该方法
     */
    public void fun2(){
        System.out.println("JNC 的Fun2...");
    }
}

public class Test {
    public static void main(String[] args) {
        Wine a = new JNC();
        a.fun1();
    }
}
-------------------------------------------------
Output:
Wine 的Fun.....
JNC 的Fun2...
```

从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。

   分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。

   所以对于多态我们可以总结如下：

   指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

   对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。

